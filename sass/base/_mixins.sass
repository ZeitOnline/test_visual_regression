=link
  &:link,
  &:visited
    @content

=on-interaction
  &:hover,
  &:active,
  &:focus
    @content

=max-width-rem($px)
  max-width: $px
  max-width: rem($px)

=min-width-rem($px)
  min-width: $px
  min-width: rem($px)

// Generate 2 color gradient, expects new W3C syntax for CSS gradients ([to bottom | 0deg = to top] vs. [top | 0deg = left])
// but handles old syntax for directions too ("top")
// Fixes bug in Compass 0.12.6
// Usage:
// - +simple-gradient(top, #f00, transparent)
// - +simple-gradient(to bottom right, #f00 0%, #fff 50%)
// - +simple-gradient(45deg, red, blue)
=simple-gradient($direction-or-angle, $from, $to)
  $start-color: $from
  $start-point: 0%
  $end-color: $to
  $end-point: 100%

  @if type-of($from) == list
    $start-color: nth($from, 1)
    $start-point: nth($from, 2)

  @if type-of($to) == list
    $end-color: nth($to, 1)
    $end-point: nth($to, 2)

  $direction: compact()
  $opposite-direction: compact()

  @if nth($direction-or-angle, 1) == 'to'
    $direction: $direction-or-angle
    $opposite-direction: opposite-position(nth($direction-or-angle, 2))
    @if length($direction-or-angle) > 2
      $opposite-direction: append($opposite-direction, opposite-position(nth($direction-or-angle, 3)), space)
  @else if unit($direction-or-angle) == deg // slightly overengineered but works for all but old-webkit-gradient
    $direction: $direction-or-angle
    $opposite-direction: abs($direction-or-angle - 450) % 360
  @else
    $direction: append($direction, to, space)
    @each $pos in $direction-or-angle
      $direction: append($direction, opposite-position($pos), space)
    $opposite-direction: $direction-or-angle

  @if type-of($direction-or-angle) != number and length($opposite-direction) == 1
    @if index(left right, $opposite-direction)
      background-image: -webkit-gradient(linear, $opposite-direction top, opposite-position($opposite-direction) top, color-stop($start-point, $start-color), color-stop($end-point, $end-color))
    @else
      background-image: -webkit-gradient(linear, left $opposite-direction, left opposite-position($opposite-direction), color-stop($start-point, $start-color), color-stop($end-point, $end-color))
  background-image: -webkit-linear-gradient($opposite-direction, $start-color $start-point, $end-color $end-point)
  background-image:    -moz-linear-gradient($opposite-direction, $start-color $start-point, $end-color $end-point)
  background-image:      -o-linear-gradient($opposite-direction, $start-color $start-point, $end-color $end-point)
  background-image:         linear-gradient($direction, $start-color $start-point, $end-color $end-point)

=fake-box-shadow-inset($color: $black, $direction: to top, $length: 60%)
  background-color: $color
  position: relative
  &:after
    content: ''
    position: absolute
    z-index: 1
    height: 100%
    width: 100%
    left: 0px
    top: 0px
    +simple-gradient($direction, rgba($color, 0.7) 0%, rgba($color, 0) $length)
    // reenable as soon as compass bug is fixed
    // +background-image(linear-gradient($direction, rgba($color, 0.7) 0%, rgba($color, 0) $length))

// Overwrite Compass mixin
// Fixes misbehaviour in Compass 0.12.6
// Fixed in Compass master (coming in v1.0)
// @todo: Remove vendor prefixes?
=border-radius($radius...)
  -webkit-border-radius: $radius
  -moz-border-radius:    $radius
  border-radius:         $radius

=no-user-select
  -webkit-touch-callout: none
  -webkit-user-select: none
  -khtml-user-select: none
  -moz-user-select: none
  -ms-user-select: none
  user-select: none

// if you change this, please change =unpadded accordingly
=padded
  padding-left: $page-padding--small
  padding-right: $page-padding--small
  +respond-min($break-1)
    padding-left: $page-padding
    padding-right: $page-padding

// should be =padded inverted
=unpadded
  margin-left: -$page-padding--small
  margin-right: -$page-padding--small
  +respond-min($break-1)
    margin-left: -$page-padding
    margin-right: -$page-padding

=bleed($max: $medium-content-width + 2*$gutter)
  margin-left: -$page-padding--small
  margin-right: -$page-padding--small
  width: auto !important
  figcaption
    margin-left: $page-padding--small !important
  +respond-min($break-1)
    margin-left: -$page-padding
    margin-right: -$page-padding
    figcaption
      margin-left: $page-padding  !important
  +respond-min($max)
    margin-left: 0
    margin-right: 0
    figcaption
      margin-left: auto !important

=visuallyhidden
  border: 0
  clip: rect(0 0 0 0)
  height: 1px
  margin: -1px
  overflow: hidden
  padding: 0
  position: absolute
  width: 1px

=ir
  display: block
  overflow: hidden
  white-space: nowrap
  text-indent: 150%

=unset-media($switch: false)
  .media__aside
    float: none
    margin-bottom: $gutter-media
    @if $switch
      margin-left: 0
    @else
      margin-right: 0

=body-type-zoom
  font-size: $font-ml
  +respond-min($break-3)
    font-size: $font-l

=input-placeholder
  ::-webkit-input-placeholder
    @content
  ::-moz-placeholder
    @content
  ::input-placeholder
    @content

=justify-children-horizontally($elements-selector)
  text-align: justify
  text-justify: distribute-all-lines
  -ms-text-justify: distribute-all-lines

  // this :after is sort-of a hack to justify the elements selected by $elements-selector
  // > short explanation:
  //   the elements get 'inline-block'-ed and can therefore be justified via 'justify'.
  //   but: justification happens for every *line* except the last one, which is left-aligned.
  //   hence the need to have an additional line, which is provided by :after.
  //   it takes up a whole line (width: 100%) and is invisible due to it's font-size and line-height of 0
  // source: http://stackoverflow.com/questions/6865194/fluid-width-with-equally-spaced-divs
  &:after
    +inline-block
    content: ''
    font-size: 0
    line-height: 0
    width: 100%

  & > *
    text-align: left // reset text-aling for child-elements

  & > #{$elements-selector}
    +inline-block
